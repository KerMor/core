function model_data = gen_approximation( model, model_data )
%GEN_APPROXIMATION Summary of this function goes here
%   Detailed explanation goes here

ps = model_data.param_samples;
xi = model_data.snapshots(:,:);
fxi = model_data.f_values(:,:);

% Repeat times vector as often as different param/input combinations exist
times = repmat(model.times,1,size(model_data.snapshots,3)*size(model_data.snapshots,4));
% Repeat param_samples for each time, then later the result for each input
idx = repmat(reshape(repmat(1:size(ps,2),length(model.times),1),1,[]),1,size(model_data.snapshots,4));
mu = model_data.param_samples(:,idx);
% Compile whole snapshot vector
vect = [times; xi; mu];

% Free some memory    
clear times idx mu;

% Compute kernel matrix (only to be computed once for all regressions)
kernel_matrix = kernelfun(vect,vect);

% Approximate each f-dimension
fdims = size(fxi,1);

% TODO: rough estimation of needed
approx_data = struct('ai',{},'b',{},'svidx',{});
svidxsum = [];
try
    wh = waitbar(0,'Initializing snapshot generation...');
    for idx = 1:fdims
        waitbar(idx/fdims,wh,sprintf('Performing SVR for dimension %d/%d ... %2.0f %%',idx,fdims,(idx/fdims)*100));
        [ai,b,svidx] = scalar_svr(fxi(idx,:),kernel_matrix,model.approx.scala);
        approx_data(idx).ai = ai;
        approx_data(idx).b = b;
        approx_data(idx).svidx = svidx;
        % collect all used support vector indices
        svidxsum = union(svidxsum,svidx);
    end
catch ME
    close(wh);
    rethrow(ME);
end

waitbar(1,wh,'Compiling approximation model data...');

vect = vect(svidxsum);
% Create transition matrix for index updates
trans(svidxsum) = 1:length(svidxsum);
% Update the support vector indices to the new index in the reduced support
% vector set. Unfortunately can first be done after finishing scalar
% approximation (hence second for-loop)
for idx = 1:fdims
    approx_data(idx).svidx = trans(approx_data(idx).svidx);
end
model_data.suppvect = vect;
model_data.approx_data = approx_data;

if ishandle(wh)
    close(wh); 
end
                
    function matrix = kernelfun(t_x_mu_tripel1,t_x_mu_tripel2)
        % Arguments are matrices with t,x and mu samples in each column
        t1 = t_x_mu_tripel1(1,:);
        x1 = t_x_mu_tripel1(2:size(xi,1)+1,:);
        mu1 = t_x_mu_tripel1(size(xi,1)+2:end,:);
        t2 = t_x_mu_tripel2(1,:);
        x2 = t_x_mu_tripel2(2:size(xi,1)+1,:);
        mu2 = t_x_mu_tripel2(size(xi,1)+2:end,:);
        
        subkernel = @(X,Y)X'*Y;
        
        matrix = subkernel(t1,t2) .* subkernel(x1,x2) .* subkernel(mu1,mu2);
    end


end

