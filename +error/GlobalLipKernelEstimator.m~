classdef GlobalLipKernelEstimator < error.BaseLipKernelEstimator
    %COMPWISEKERNELESTIMATOR Summary of this class goes here
    %   Detailed explanation goes here
    
    methods
        function this = GlobalLipKernelEstimator(rmodel)
            this.ExtraODEDims = 1;
            
            if nargin == 1
                this.setReducedModel(rmodel);
            end
        end
        
        function copy = clone(this)
            % Creates a deep copy of this estimator instance.
            copy = error.GlobalLipKernelEstimator;
            copy = clone@error.BaseLipKernelEstimator(this, copy);
        end
        
        function e = evalODEPart(this, x, t, mu, ut)
            phi = this.ReducedModel.System.f.evaluateAtCenters(x(1:end-this.ExtraODEDims,:), t, mu);
            
%             rmodel = this.ReducedModel;
%             fm = rmodel.FullModel;
%                 
%             % Obtain linear output conversion matrix (estimators only
%             % work for LTI case)
%             C = fm.System.C.evaluate(0,[]);
%             % Get full d x N coeff matrix of core function
%             Ma = fm.System.f.Ma;
%                 
%             
%             % Only linear input conversion (B = const. matrix) allowed so
%             % far! mu,0 is only to let
%             if ~isempty(fm.System.B)
%                 B = fm.System.B.evaluate([],[]);
%                 e = sqrt(sum(C*(Ma*phi - rmodel.V*(rmodel.W'*Ma)*phi ...
%                     + B*ut - rmodel.V*(rmodel.W'*B)*ut),1));
%             else
%                 e = sqrt(sum(C*(Ma*phi - rmodel.V*(rmodel.W'*Ma)*phi),1));
%             end

            rmodel = this.ReducedModel;
            fm = rmodel.FullModel;
                
            % Obtain linear output conversion matrix (estimators only
            % work for LTI case)
            C = fm.System.C.evaluate(0,[]);
            % Get full d x N coeff matrix of core function
            Ma = fm.System.f.Ma;
            
            % Compute projection part matrices, without creating a
            % d x d matrix (too big!)
            CVWM = (C*rmodel.V)*(rmodel.W'*Ma);
            CM = C*Ma;
            %e = phi'*CM'*(CM*phi) - 2*phi'*CM'*CVWM*phi + phi'*CVWM'*(CVWM*phi);
            e = (CM-CVWM)*phi;
            e = e'*e;
            e = sqrt(sum((C*(Ma*phi - rmodel.V*(rmodel.W'*Ma)*phi),1));

            
%             % An input function u is set
%             if nargin == 5
%                 e = phi'*this.M1*phi + phi'*this.M2*ut + ut'*this.M3*ut;
%                 % No input case
%             else
%                 e = phi'*this.M1*phi;
%             end
            e = sqrt(max(e,0));
        end
        
        function process(this, t, x, mu, inputidx)%#ok
            % @todo also take into account FullModel.Approx at cf computation!
            eint = x(end-this.ExtraODEDims+1:end,:);
            if all(eint == 0)
                warning('CompWiseErrorEstimator:process','Integral part is all zero. Attention!');
            end
            %cf = this.ReducedModel.FullModel.System.f.getGlobalLipschitz(t,mu);
            C = this.ReducedModel.FullModel.System.C.evaluate(0,[]);
            f = this.ReducedModel.FullModel.System.f;
            cf = sum(sqrt(sum((C*f.Ma).^2,1))) * f.SystemKernel.getGlobalLipschitz;
            
            pt1 = exp(cf .* reshape(t,1,[]));
            pt2 = (eint + this.ReducedModel.getExo(mu));
            this.LastError = pt1 .* pt2;
        end
        
        function e0 = getE0(this, mu)%#ok
            % Returns the initial error at `t=0` of the integral part.
            % For this estimator, this is simply one dimension and zero.
            e0 = 0;
        end
        
    end
    
    methods(Static)
        function errmsg = validModelForEstimator(rmodel)
            % Validations
            errmsg = validModelForEstimator@error.BaseLipKernelEstimator(rmodel);
            if isempty(errmsg) && ~isa(rmodel.FullModel.System.f,'dscomponents.IGlobalLipschitz')
                errmsg = 'The full model''s core function must implement the dscomponents.IGlobalLipschitz interface for this error estimator.';
            end
        end
    end
    
end