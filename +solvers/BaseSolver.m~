classdef BaseSolver < handle
    % Base class for all KerMor ODE solvers
    %
    % Simply defines an interfaces for a solve function and provides common
    % ODE solver properties.
    %
    % @todo: Write tests for solvers.
    
    properties
        % Maximum time step for solver.
        %
        % Default: [] (Use solver's default settings)
        MaxStep = [];
        
        % The initial step size for the solver.
        % So far only used by the MLWrapper class for the native matlab
        % solvers.
        %
        % Default: [] (User solver's default settings)
        InitialStep = [];
    end
    
    properties(SetAccess=protected)
        % The solver's name
        Name = 'KerMor BaseSolver';
    end
    
    methods(Access=protected)
        function [times, tout, outputtimes] = getCompTimes(this, t)
            % Computes the computation and effective output times for a
            % given input time vector t and the desired timestep dt.
            %
            % Parameters:
            % t: The desired times t. Either a two element vector
            % containing start time `t_0` and end time `T` or a row vector
            % `t=[t_0, t_1, \ldots, T]`.
            % dt: The internal timestep to use during computation.
            %
            % Return values:
            % times: The actual times at which to compute the solution.
            % tout: The effective times that are being returned along with
            % the solution values.
            % outputtimes: A logical row vector of the size of times that
            % indicates which element from the times vector also belongs to
            % the tout vector.
            %
            % % @todo muss nicht so viel sein wie t(1):this.MaxStep:t(end),
            % einfacher ist zu checken wo im gegebenen t die abstände
            % größer als MaxStep sind; dann muss nur verfeinert werden.
            % @todo InitialStep mit einbauen!
            
            if numel(t) == 2
                % Validity checks
                if t(1) >= t(2)
                    error('The end time cannot be lower than or equal to the start time.');
                end
                
                times = t(1):this.MaxStep:t(2);
                outputtimes = true(1,length(times));
                tout = times;
            else
                % Validity checks
                if any(abs(sort(t) - t) > 100*eps)
                    error('If manual time steps are given, the vector must be strictly monotoneously increasing.');
                end
                
                idx = fliplr(find(t(2:end)-t(1:end-1) > this.MaxStep));
                if ~isempty(idx)
                    times = t;
                    outputtimes = true(length(t));
                    for i=idx
                        times = [times(1:i-1) times(i):this.MaxStep:times(i+1) times(i+2:end)];
                        outputtimes = [outputtimes(1:i-1) outputtimes(i):this.MaxStep:times(i+1) outputtimes(i+2:end)]
                    end
                    tidx = 1;
                    outputtimes = false(1,length(times));
                    for idx = 1:length(times)
                        if times(idx) - t(tidx) < 100*eps
                            outputtimes(idx) = true;
                            tidx = tidx + 1;
                        end
                    end
                else
                    times = t;
                end
                
                
%                 if any(t(2:end)-t(1:end-1) > this.MaxStep)
%                     
%                     mintimes = t(1):this.MaxStep:t(end);
%                     
%                     joint = [t mintimes];
%                     times = sort(joint);
%                     % Remove double times (each time is unique in each array,
%                     % so there are at max two identical ones ..)
%                     times(times(2:end)-times(1:end-1) < 100*eps) = [];
%                     
%                     tidx = 1;
%                     outputtimes = false(1,length(times));
%                     for idx = 1:length(times)
%                         if times(idx) - t(tidx) < 100*eps
%                             outputtimes(idx) = true;
%                             tidx = tidx + 1;
%                         end
%                     end
%                     %T = repmat(t,length(times),1);
%                     %Ti = repmat(times,length(t),1)';
%                     %outputtimes = sum(T-Ti < 100*eps,2) > 0;
%                     tout = times(outputtimes);
%                     % Security check
%                     if numel(times) > max(numel(t),numel(mintimes))
%                         error('Unexpected error: Resulting time vector is longer than the max of the given time steps and the minimal needed ones.');
%                     end
%                 end
                
                
            end
        end
    end
    
    methods(Abstract)
        % The abstract solve function for the ODE solver.
        %
        % Parameters:
        % t: Either a two dimensional vector with t(1) < t(2) specifiying
        % the start and end time, or a greater or equal to three
        % dimensional, strictly monotoneously increasing vector explicitly
        % setting the desired output times. Depending on the MaxStep
        % property, the solver can work with a finer time step internally.
        [t,y] = solve(odefun, t, x0, opts);
    end
    
    methods
        function set.MaxStep(this, value)
            if isempty(value)
                this.MaxStep = value;
                return;
            elseif ~isposrealscalar(value)
                error('Positive real scalar expected.');
            elseif value == 0
                error('Maximum time step must be greater than zero. Use [] to unset.');
            end
            this.MaxStep = value;
        end
        
        function set.InitialStep(this, value)
            if ~isposrealscalar(value)
                error('Positive real scalar expected.');
            end
            this.InitialStep = value;
        end
    end
    
    methods(Static)
        
        function res = test_SolverSpeedTest
            m = models.synth.KernelTest(200);
            
            perform(solvers.MLWrapper(@ode23));
            perform(solvers.MLWrapper(@ode45));
            perform(solvers.ExplEuler);
            perform(solvers.Heun);
            
            res = 1;
            
            function perform(solver)
                m.ODESolver = solver;
                tic;
                m.offlineGenerations;
                r = m.buildReducedModel;
                t = toc;
                fprintf('Using solver %s\n',m.ODESolver.Name);
                fprintf('Offline generations time: %f\n',t);
                [ti,x,xr,t,tr,tr_noerr] = r.getTrajectories;
                fprintf('Online simulations time\nFull detail: %fs\nReduced with error estimator: %fs\nReduced without error estimation:%fs\n\n',t,tr,tr_noerr);
            end
        end
        
    end
    
end

